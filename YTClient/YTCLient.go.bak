package YTClient

import (
	"SqliteClient"
	"log"
	"net/http"
	"strings"
	"time"

	"google.golang.org/api/googleapi/transport"
	youtube "google.golang.org/api/youtube/v3"
)

//a const for building video links
const watchyt = "https://www.youtube.com/watch?v="

/*YoutubeClient is filled with an api key, then call Service() to generate a youtube api
client. Methods can then be attached to call the api such as RecentVideo */
type YoutubeClient struct {
	APIKey   string
	service  *youtube.Service
	SQLCli   *SqliteClient.ChannelWatch
	channels map[string]*YoutubeChannel
}

type YoutubeChannel struct {
	channelLink string
	channelID   string
	recentVid   string
	lastUpdate  time.Time
}

func (c *YoutubeClient) AddChannels() {
	var err error
	for _, v := range c.SQLCli.WatchList() {

		channel := YoutubeChannel{}
		channel.channelLink = v
		channel.channelID, err = c.ExtractID(channel.channelLink)
		if err != nil {
			continue
			log.Printf("Failed to add channel: %v", err)
		}
		c.channels[channel.channelID] = &channel
	}
}

func (c *YoutubeClient) ExtractID(url string) (string, error) {
	s := strings.Split(url, "/")
	if strings.Contains(url, "/channel/") {
		c.SQLCli.UpdateChanID(url, s[len(s)-1])
		return s[len(s)-1], nil
	}
	call := c.service.Channels.List("id")
	call = call.ForUsername(s[len(s)-1])
	resp, err := call.Do()
	if err != nil {
		return "", err
	}
	c.SQLCli.UpdateChanID(url, resp.Items[0].Id)
	return resp.Items[0].Id, nil
}

/*Generates a youtube client to call api on */
func (c *YoutubeClient) Service() {
	client := &http.Client{Transport: &transport.APIKey{Key: c.APIKey}}
	ser, err := youtube.New(client)
	if err != nil {
		log.Fatalf("Error creating youtube client: %v", err)
	}
	c.service = ser
	c.channels = make(map[string]*YoutubeChannel)
}

func (c *YoutubeClient) RecentVideo(timeAfter time.Time) []string {
	var s []string
	var urls []string
	for key, _ := range c.channels {
		s = append(s, key)
	}
	channelList := strings.Join(s[:], ",")

	//fmt.Printf("Checking results of %v at %v\n", channel.channelID, YTime(time.Now()))
	//building our request, first is type of info we want
	call := c.service.Channels.List("contentDetails")
	//we want grouped results of channel IDs hopefully conserves quota
	call = call.Id(channelList)
	response, err := call.Do()
	if err != nil {
		log.Printf("Failure executing request: %v", err)
		return []string{}
	}
	if len(response.Items) == 0 {
		return []string{}
	}
	for _, respItem := range response.Items {
		respChan := respItem.Id
		uploadsID := respItem.ContentDetails.RelatedPlaylists.Uploads

		playlistCall := c.service.PlaylistItems.List("contentDetails")
		playlistCall = playlistCall.PlaylistId(uploadsID)
		playlistResponse, err := playlistCall.Do()
		if err != nil {
			log.Printf("\n\n[!]Failure executing request: %v\n\n", err)
			return []string{}
		}
		//fmt.Printf("Response: %v\n", playlistResponse.Items)
		if len(playlistResponse.Items) == 0 {
			return []string{}
		}
		//fmt.Printf("Found broadcast: %v created at:%v\n", response.Items[0].Id.VideoId, response.Items[0].Snippet.PublishedAt)
		checkChan := c.channels[respChan]
		rVID := checkChan.Recent(playlistResponse, respChan, c.SQLCli)
		if rVID != "" {
			c.channels[respChan].recentVid = rVID
			urls = append(urls, createLink(rVID))
		}
	}
	return urls
}

func (c *YoutubeChannel) Recent(result *youtube.PlaylistItemListResponse, channel string, db *SqliteClient.ChannelWatch) string {

	publishedAt := result.Items[0].ContentDetails.VideoPublishedAt
	res := db.UpdateVideo(channel, result.Items[0].ContentDetails.VideoId, publishedAt)
	if res != false {
		//we actually have a new video
		t, err := time.Parse(time.RFC3339, publishedAt)
		//fmt.Printf("Found video :%v published at:%v\n", result.Items[0].ContentDetails.VideoId, publishedAt)
		if err != nil {
			log.Printf("Error parsing time: %v err:%v", publishedAt, err)
			return ""
		}
		c.lastUpdate = t
		return result.Items[0].ContentDetails.VideoId
	}
	return ""
}
func createLink(vID string) string {
	url := watchyt + vID
	return url
}

/*yTime returns a youtube approved time string from a time.Time format*/
func YTime(t time.Time) string {
	return t.UTC().Format(time.RFC3339)

}
